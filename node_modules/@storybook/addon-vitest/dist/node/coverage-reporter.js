import CJS_COMPAT_NODE_URL_vppyn5e0su from 'node:url';
import CJS_COMPAT_NODE_PATH_vppyn5e0su from 'node:path';
import CJS_COMPAT_NODE_MODULE_vppyn5e0su from "node:module";

var __filename = CJS_COMPAT_NODE_URL_vppyn5e0su.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_vppyn5e0su.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_vppyn5e0su.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  require_gte
} from "../_node-chunks/chunk-NYSDXFJX.js";
import {
  __commonJS,
  __name,
  __require,
  __toESM
} from "../_node-chunks/chunk-I3RGDGG2.js";

// ../../node_modules/istanbul-lib-report/node_modules/make-dir/index.js
var require_make_dir = __commonJS({
  "../../node_modules/istanbul-lib-report/node_modules/make-dir/index.js"(exports, module) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    var { promisify } = __require("util");
    var semverGte = require_gte();
    var useNativeRecursiveOption = semverGte(process.version, "10.12.0");
    var checkPath = /* @__PURE__ */ __name((pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    }, "checkPath");
    var processOptions = /* @__PURE__ */ __name((options) => {
      const defaults = {
        mode: 511,
        fs
      };
      return {
        ...defaults,
        ...options
      };
    }, "processOptions");
    var permissionError = /* @__PURE__ */ __name((pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    }, "permissionError");
    var makeDir = /* @__PURE__ */ __name(async (input, options) => {
      checkPath(input);
      options = processOptions(options);
      const mkdir = promisify(options.fs.mkdir);
      const stat = promisify(options.fs.stat);
      if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {
        const pth = path.resolve(input);
        await mkdir(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = /* @__PURE__ */ __name(async (pth) => {
        try {
          await mkdir(pth, options.mode);
          return pth;
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
          return pth;
        }
      }, "make");
      return make(path.resolve(input));
    }, "makeDir");
    module.exports = makeDir;
    module.exports.sync = (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
        const pth = path.resolve(input);
        fs.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = /* @__PURE__ */ __name((pth) => {
        try {
          options.fs.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path.dirname(pth));
            return make(pth);
          }
          try {
            if (!options.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
        return pth;
      }, "make");
      return make(path.resolve(input));
    };
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    __name(translateLevel, "translateLevel");
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    __name(supportsColor, "supportsColor");
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    __name(getSupportLevel, "getSupportLevel");
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/istanbul-lib-report/lib/file-writer.js
var require_file_writer = __commonJS({
  "../../node_modules/istanbul-lib-report/lib/file-writer.js"(exports, module) {
    "use strict";
    var path = __require("path");
    var fs = __require("fs");
    var mkdirp = require_make_dir();
    var supportsColor = require_supports_color();
    var ContentWriter = class {
      static {
        __name(this, "ContentWriter");
      }
      /**
       * returns the colorized version of a string. Typically,
       * content writers that write to files will return the
       * same string and ones writing to a tty will wrap it in
       * appropriate escape sequences.
       * @param {String} str the string to colorize
       * @param {String} clazz one of `high`, `medium` or `low`
       * @returns {String} the colorized form of the string
       */
      colorize(str) {
        return str;
      }
      /**
       * writes a string appended with a newline to the destination
       * @param {String} str the string to write
       */
      println(str) {
        this.write(`${str}
`);
      }
      /**
       * closes this content writer. Should be called after all writes are complete.
       */
      close() {
      }
    };
    var FileContentWriter = class extends ContentWriter {
      static {
        __name(this, "FileContentWriter");
      }
      constructor(fd) {
        super();
        this.fd = fd;
      }
      write(str) {
        fs.writeSync(this.fd, str);
      }
      close() {
        fs.closeSync(this.fd);
      }
    };
    var capture = false;
    var output = "";
    var ConsoleWriter = class extends ContentWriter {
      static {
        __name(this, "ConsoleWriter");
      }
      write(str) {
        if (capture) {
          output += str;
        } else {
          process.stdout.write(str);
        }
      }
      colorize(str, clazz) {
        const colors = {
          low: "31;1",
          medium: "33;1",
          high: "32;1"
        };
        if (supportsColor.stdout && colors[clazz]) {
          return `\x1B[${colors[clazz]}m${str}\x1B[0m`;
        }
        return str;
      }
    };
    var FileWriter = class _FileWriter {
      static {
        __name(this, "FileWriter");
      }
      constructor(baseDir) {
        if (!baseDir) {
          throw new Error("baseDir must be specified");
        }
        this.baseDir = baseDir;
      }
      /**
       * static helpers for capturing stdout report output;
       * super useful for tests!
       */
      static startCapture() {
        capture = true;
      }
      static stopCapture() {
        capture = false;
      }
      static getOutput() {
        return output;
      }
      static resetOutput() {
        output = "";
      }
      /**
       * returns a FileWriter that is rooted at the supplied subdirectory
       * @param {String} subdir the subdirectory under which to root the
       *  returned FileWriter
       * @returns {FileWriter}
       */
      writerForDir(subdir) {
        if (path.isAbsolute(subdir)) {
          throw new Error(
            `Cannot create subdir writer for absolute path: ${subdir}`
          );
        }
        return new _FileWriter(`${this.baseDir}/${subdir}`);
      }
      /**
       * copies a file from a source directory to a destination name
       * @param {String} source path to source file
       * @param {String} dest relative path to destination file
       * @param {String} [header=undefined] optional text to prepend to destination
       *  (e.g., an "this file is autogenerated" comment, copyright notice, etc.)
       */
      copyFile(source, dest, header) {
        if (path.isAbsolute(dest)) {
          throw new Error(`Cannot write to absolute path: ${dest}`);
        }
        dest = path.resolve(this.baseDir, dest);
        mkdirp.sync(path.dirname(dest));
        let contents;
        if (header) {
          contents = header + fs.readFileSync(source, "utf8");
        } else {
          contents = fs.readFileSync(source);
        }
        fs.writeFileSync(dest, contents);
      }
      /**
       * returns a content writer for writing content to the supplied file.
       * @param {String|null} file the relative path to the file or the special
       *  values `"-"` or `null` for writing to the console
       * @returns {ContentWriter}
       */
      writeFile(file) {
        if (file === null || file === "-") {
          return new ConsoleWriter();
        }
        if (path.isAbsolute(file)) {
          throw new Error(`Cannot write to absolute path: ${file}`);
        }
        file = path.resolve(this.baseDir, file);
        mkdirp.sync(path.dirname(file));
        return new FileContentWriter(fs.openSync(file, "w"));
      }
    };
    module.exports = FileWriter;
  }
});

// ../../node_modules/istanbul-lib-report/lib/xml-writer.js
var require_xml_writer = __commonJS({
  "../../node_modules/istanbul-lib-report/lib/xml-writer.js"(exports, module) {
    "use strict";
    var INDENT = "  ";
    function attrString(attrs) {
      return Object.entries(attrs || {}).map(([k, v]) => ` ${k}="${v}"`).join("");
    }
    __name(attrString, "attrString");
    var XMLWriter = class {
      static {
        __name(this, "XMLWriter");
      }
      constructor(contentWriter) {
        this.cw = contentWriter;
        this.stack = [];
      }
      indent(str) {
        return this.stack.map(() => INDENT).join("") + str;
      }
      /**
       * writes the opening XML tag with the supplied attributes
       * @param {String} name tag name
       * @param {Object} [attrs=null] attrs attributes for the tag
       */
      openTag(name, attrs) {
        const str = this.indent(`<${name + attrString(attrs)}>`);
        this.cw.println(str);
        this.stack.push(name);
      }
      /**
       * closes an open XML tag.
       * @param {String} name - tag name to close. This must match the writer's
       *  notion of the tag that is currently open.
       */
      closeTag(name) {
        if (this.stack.length === 0) {
          throw new Error(`Attempt to close tag ${name} when not opened`);
        }
        const stashed = this.stack.pop();
        const str = `</${name}>`;
        if (stashed !== name) {
          throw new Error(
            `Attempt to close tag ${name} when ${stashed} was the one open`
          );
        }
        this.cw.println(this.indent(str));
      }
      /**
       * writes a tag and its value opening and closing it at the same time
       * @param {String} name tag name
       * @param {Object} [attrs=null] attrs tag attributes
       * @param {String} [content=null] content optional tag content
       */
      inlineTag(name, attrs, content) {
        let str = "<" + name + attrString(attrs);
        if (content) {
          str += `>${content}</${name}>`;
        } else {
          str += "/>";
        }
        str = this.indent(str);
        this.cw.println(str);
      }
      /**
       * closes all open tags and ends the document
       */
      closeAll() {
        this.stack.slice().reverse().forEach((name) => {
          this.closeTag(name);
        });
      }
    };
    module.exports = XMLWriter;
  }
});

// ../../node_modules/istanbul-lib-report/lib/tree.js
var require_tree = __commonJS({
  "../../node_modules/istanbul-lib-report/lib/tree.js"(exports, module) {
    "use strict";
    var Visitor = class {
      static {
        __name(this, "Visitor");
      }
      constructor(delegate) {
        this.delegate = delegate;
      }
    };
    ["Start", "End", "Summary", "SummaryEnd", "Detail"].map((k) => `on${k}`).forEach((fn) => {
      Object.defineProperty(Visitor.prototype, fn, {
        writable: true,
        value(node, state) {
          if (typeof this.delegate[fn] === "function") {
            this.delegate[fn](node, state);
          }
        }
      });
    });
    var CompositeVisitor = class extends Visitor {
      static {
        __name(this, "CompositeVisitor");
      }
      constructor(visitors) {
        super();
        if (!Array.isArray(visitors)) {
          visitors = [visitors];
        }
        this.visitors = visitors.map((v) => {
          if (v instanceof Visitor) {
            return v;
          }
          return new Visitor(v);
        });
      }
    };
    ["Start", "Summary", "SummaryEnd", "Detail", "End"].map((k) => `on${k}`).forEach((fn) => {
      Object.defineProperty(CompositeVisitor.prototype, fn, {
        value(node, state) {
          this.visitors.forEach((v) => {
            v[fn](node, state);
          });
        }
      });
    });
    var BaseNode = class {
      static {
        __name(this, "BaseNode");
      }
      isRoot() {
        return !this.getParent();
      }
      /**
       * visit all nodes depth-first from this node down. Note that `onStart`
       * and `onEnd` are never called on the visitor even if the current
       * node is the root of the tree.
       * @param visitor a full visitor that is called during tree traversal
       * @param state optional state that is passed around
       */
      visit(visitor, state) {
        if (this.isSummary()) {
          visitor.onSummary(this, state);
        } else {
          visitor.onDetail(this, state);
        }
        this.getChildren().forEach((child) => {
          child.visit(visitor, state);
        });
        if (this.isSummary()) {
          visitor.onSummaryEnd(this, state);
        }
      }
    };
    var BaseTree = class {
      static {
        __name(this, "BaseTree");
      }
      constructor(root) {
        this.root = root;
      }
      /**
       * returns the root node of the tree
       */
      getRoot() {
        return this.root;
      }
      /**
       * visits the tree depth-first with the supplied partial visitor
       * @param visitor - a potentially partial visitor
       * @param state - the state to be passed around during tree traversal
       */
      visit(visitor, state) {
        if (!(visitor instanceof Visitor)) {
          visitor = new Visitor(visitor);
        }
        visitor.onStart(this.getRoot(), state);
        this.getRoot().visit(visitor, state);
        visitor.onEnd(this.getRoot(), state);
      }
    };
    module.exports = {
      BaseTree,
      BaseNode,
      Visitor,
      CompositeVisitor
    };
  }
});

// ../../node_modules/istanbul-lib-report/lib/watermarks.js
var require_watermarks = __commonJS({
  "../../node_modules/istanbul-lib-report/lib/watermarks.js"(exports, module) {
    "use strict";
    module.exports = {
      getDefault() {
        return {
          statements: [50, 80],
          functions: [50, 80],
          branches: [50, 80],
          lines: [50, 80]
        };
      }
    };
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/percent.js
var require_percent = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/percent.js"(exports, module) {
    "use strict";
    module.exports = /* @__PURE__ */ __name(function percent(covered, total) {
      let tmp;
      if (total > 0) {
        tmp = 1e3 * 100 * covered / total;
        return Math.floor(tmp / 10) / 100;
      } else {
        return 100;
      }
    }, "percent");
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/data-properties.js
var require_data_properties = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/data-properties.js"(exports, module) {
    "use strict";
    module.exports = /* @__PURE__ */ __name(function dataProperties(klass, properties) {
      properties.forEach((p) => {
        Object.defineProperty(klass.prototype, p, {
          enumerable: true,
          get() {
            return this.data[p];
          }
        });
      });
    }, "dataProperties");
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/coverage-summary.js
var require_coverage_summary = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/coverage-summary.js"(exports, module) {
    "use strict";
    var percent = require_percent();
    var dataProperties = require_data_properties();
    function blankSummary() {
      const empty = /* @__PURE__ */ __name(() => ({
        total: 0,
        covered: 0,
        skipped: 0,
        pct: "Unknown"
      }), "empty");
      return {
        lines: empty(),
        statements: empty(),
        functions: empty(),
        branches: empty(),
        branchesTrue: empty()
      };
    }
    __name(blankSummary, "blankSummary");
    function assertValidSummary(obj) {
      const valid = obj && obj.lines && obj.statements && obj.functions && obj.branches;
      if (!valid) {
        throw new Error(
          "Invalid summary coverage object, missing keys, found:" + Object.keys(obj).join(",")
        );
      }
    }
    __name(assertValidSummary, "assertValidSummary");
    var CoverageSummary = class _CoverageSummary {
      static {
        __name(this, "CoverageSummary");
      }
      /**
       * @constructor
       * @param {Object|CoverageSummary} [obj=undefined] an optional data object or
       * another coverage summary to initialize this object with.
       */
      constructor(obj) {
        if (!obj) {
          this.data = blankSummary();
        } else if (obj instanceof _CoverageSummary) {
          this.data = obj.data;
        } else {
          this.data = obj;
        }
        assertValidSummary(this.data);
      }
      /**
       * merges a second summary coverage object into this one
       * @param {CoverageSummary} obj - another coverage summary object
       */
      merge(obj) {
        const keys = [
          "lines",
          "statements",
          "branches",
          "functions",
          "branchesTrue"
        ];
        keys.forEach((key) => {
          if (obj[key]) {
            this[key].total += obj[key].total;
            this[key].covered += obj[key].covered;
            this[key].skipped += obj[key].skipped;
            this[key].pct = percent(this[key].covered, this[key].total);
          }
        });
        return this;
      }
      /**
       * returns a POJO that is JSON serializable. May be used to get the raw
       * summary object.
       */
      toJSON() {
        return this.data;
      }
      /**
       * return true if summary has no lines of code
       */
      isEmpty() {
        return this.lines.total === 0;
      }
    };
    dataProperties(CoverageSummary, [
      "lines",
      "statements",
      "functions",
      "branches",
      "branchesTrue"
    ]);
    module.exports = {
      CoverageSummary
    };
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/file-coverage.js
var require_file_coverage = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/file-coverage.js"(exports, module) {
    "use strict";
    var percent = require_percent();
    var dataProperties = require_data_properties();
    var { CoverageSummary } = require_coverage_summary();
    function emptyCoverage(filePath, reportLogic) {
      const cov = {
        path: filePath,
        statementMap: {},
        fnMap: {},
        branchMap: {},
        s: {},
        f: {},
        b: {}
      };
      if (reportLogic) cov.bT = {};
      return cov;
    }
    __name(emptyCoverage, "emptyCoverage");
    function assertValidObject(obj) {
      const valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;
      if (!valid) {
        throw new Error(
          "Invalid file coverage object, missing keys, found:" + Object.keys(obj).join(",")
        );
      }
    }
    __name(assertValidObject, "assertValidObject");
    var keyFromLoc = /* @__PURE__ */ __name(({ start, end }) => `${start.line}|${start.column}|${end.line}|${end.column}`, "keyFromLoc");
    var isObj = /* @__PURE__ */ __name((o) => !!o && typeof o === "object", "isObj");
    var isLineCol = /* @__PURE__ */ __name((o) => isObj(o) && typeof o.line === "number" && typeof o.column === "number", "isLineCol");
    var isLoc = /* @__PURE__ */ __name((o) => isObj(o) && isLineCol(o.start) && isLineCol(o.end), "isLoc");
    var getLoc = /* @__PURE__ */ __name((o) => isLoc(o) ? o : isLoc(o.loc) ? o.loc : null, "getLoc");
    var findNearestContainer = /* @__PURE__ */ __name((item, map) => {
      const itemLoc = getLoc(item);
      if (!itemLoc) return null;
      let nearestContainingItem = null;
      let containerDistance = null;
      let containerKey = null;
      for (const [i, mapItem] of Object.entries(map)) {
        const mapLoc = getLoc(mapItem);
        if (!mapLoc) continue;
        const distance = [
          itemLoc.start.line - mapLoc.start.line,
          itemLoc.start.column - mapLoc.start.column,
          mapLoc.end.line - itemLoc.end.line,
          mapLoc.end.column - itemLoc.end.column
        ];
        if (distance[0] < 0 || distance[2] < 0 || distance[0] === 0 && distance[1] < 0 || distance[2] === 0 && distance[3] < 0) {
          continue;
        }
        if (nearestContainingItem === null) {
          containerDistance = distance;
          nearestContainingItem = mapItem;
          containerKey = i;
          continue;
        }
        const closerBefore = distance[0] < containerDistance[0] || distance[0] === 0 && distance[1] < containerDistance[1];
        const closerAfter = distance[2] < containerDistance[2] || distance[2] === 0 && distance[3] < containerDistance[3];
        if (closerBefore || closerAfter) {
          containerDistance = distance;
          nearestContainingItem = mapItem;
          containerKey = i;
        }
      }
      return containerKey;
    }, "findNearestContainer");
    var addHits = /* @__PURE__ */ __name((aHits, bHits) => {
      if (typeof aHits === "number" && typeof bHits === "number") {
        return aHits + bHits;
      } else if (Array.isArray(aHits) && Array.isArray(bHits)) {
        return aHits.map((a, i) => (a || 0) + (bHits[i] || 0));
      }
      return null;
    }, "addHits");
    var addNearestContainerHits = /* @__PURE__ */ __name((item, itemHits, map, mapHits) => {
      const container = findNearestContainer(item, map);
      if (container) {
        return addHits(itemHits, mapHits[container]);
      } else {
        return itemHits;
      }
    }, "addNearestContainerHits");
    var mergeProp = /* @__PURE__ */ __name((aHits, aMap, bHits, bMap, itemKey = keyFromLoc) => {
      const aItems = {};
      for (const [key, itemHits] of Object.entries(aHits)) {
        const item = aMap[key];
        aItems[itemKey(item)] = [itemHits, item];
      }
      const bItems = {};
      for (const [key, itemHits] of Object.entries(bHits)) {
        const item = bMap[key];
        bItems[itemKey(item)] = [itemHits, item];
      }
      const mergedItems = {};
      for (const [key, aValue] of Object.entries(aItems)) {
        let aItemHits = aValue[0];
        const aItem = aValue[1];
        const bValue = bItems[key];
        if (!bValue) {
          aItemHits = addNearestContainerHits(aItem, aItemHits, bMap, bHits);
        } else {
          aItemHits = addHits(aItemHits, bValue[0]);
        }
        mergedItems[key] = [aItemHits, aItem];
      }
      for (const [key, bValue] of Object.entries(bItems)) {
        let bItemHits = bValue[0];
        const bItem = bValue[1];
        if (mergedItems[key]) continue;
        bItemHits = addNearestContainerHits(bItem, bItemHits, aMap, aHits);
        mergedItems[key] = [bItemHits, bItem];
      }
      const hits = {};
      const map = {};
      Object.values(mergedItems).forEach(([itemHits, item], i) => {
        hits[i] = itemHits;
        map[i] = item;
      });
      return [hits, map];
    }, "mergeProp");
    var FileCoverage = class _FileCoverage {
      static {
        __name(this, "FileCoverage");
      }
      /**
       * @constructor
       * @param {Object|FileCoverage|String} pathOrObj is a string that initializes
       * and empty coverage object with the specified file path or a data object that
       * has all the required properties for a file coverage object.
       */
      constructor(pathOrObj, reportLogic = false) {
        if (!pathOrObj) {
          throw new Error(
            "Coverage must be initialized with a path or an object"
          );
        }
        if (typeof pathOrObj === "string") {
          this.data = emptyCoverage(pathOrObj, reportLogic);
        } else if (pathOrObj instanceof _FileCoverage) {
          this.data = pathOrObj.data;
        } else if (typeof pathOrObj === "object") {
          this.data = pathOrObj;
        } else {
          throw new Error("Invalid argument to coverage constructor");
        }
        assertValidObject(this.data);
      }
      /**
       * returns computed line coverage from statement coverage.
       * This is a map of hits keyed by line number in the source.
       */
      getLineCoverage() {
        const statementMap = this.data.statementMap;
        const statements = this.data.s;
        const lineMap = /* @__PURE__ */ Object.create(null);
        Object.entries(statements).forEach(([st, count]) => {
          if (!statementMap[st]) {
            return;
          }
          const { line } = statementMap[st].start;
          const prevVal = lineMap[line];
          if (prevVal === void 0 || prevVal < count) {
            lineMap[line] = count;
          }
        });
        return lineMap;
      }
      /**
       * returns an array of uncovered line numbers.
       * @returns {Array} an array of line numbers for which no hits have been
       *  collected.
       */
      getUncoveredLines() {
        const lc = this.getLineCoverage();
        const ret = [];
        Object.entries(lc).forEach(([l, hits]) => {
          if (hits === 0) {
            ret.push(l);
          }
        });
        return ret;
      }
      /**
       * returns a map of branch coverage by source line number.
       * @returns {Object} an object keyed by line number. Each object
       * has a `covered`, `total` and `coverage` (percentage) property.
       */
      getBranchCoverageByLine() {
        const branchMap = this.branchMap;
        const branches = this.b;
        const ret = {};
        Object.entries(branchMap).forEach(([k, map]) => {
          const line = map.line || map.loc.start.line;
          const branchData = branches[k];
          ret[line] = ret[line] || [];
          ret[line].push(...branchData);
        });
        Object.entries(ret).forEach(([k, dataArray]) => {
          const covered = dataArray.filter((item) => item > 0);
          const coverage = covered.length / dataArray.length * 100;
          ret[k] = {
            covered: covered.length,
            total: dataArray.length,
            coverage
          };
        });
        return ret;
      }
      /**
       * return a JSON-serializable POJO for this file coverage object
       */
      toJSON() {
        return this.data;
      }
      /**
       * merges a second coverage object into this one, updating hit counts
       * @param {FileCoverage} other - the coverage object to be merged into this one.
       *  Note that the other object should have the same structure as this one (same file).
       */
      merge(other) {
        if (other.all === true) {
          return;
        }
        if (this.all === true) {
          this.data = other.data;
          return;
        }
        let [hits, map] = mergeProp(
          this.s,
          this.statementMap,
          other.s,
          other.statementMap
        );
        this.data.s = hits;
        this.data.statementMap = map;
        const keyFromLocProp = /* @__PURE__ */ __name((x) => keyFromLoc(x.loc), "keyFromLocProp");
        const keyFromLocationsProp = /* @__PURE__ */ __name((x) => keyFromLoc(x.locations[0]), "keyFromLocationsProp");
        [hits, map] = mergeProp(
          this.f,
          this.fnMap,
          other.f,
          other.fnMap,
          keyFromLocProp
        );
        this.data.f = hits;
        this.data.fnMap = map;
        [hits, map] = mergeProp(
          this.b,
          this.branchMap,
          other.b,
          other.branchMap,
          keyFromLocationsProp
        );
        this.data.b = hits;
        this.data.branchMap = map;
        if (this.bT && other.bT) {
          [hits, map] = mergeProp(
            this.bT,
            this.branchMap,
            other.bT,
            other.branchMap,
            keyFromLocationsProp
          );
          this.data.bT = hits;
        }
      }
      computeSimpleTotals(property) {
        let stats = this[property];
        if (typeof stats === "function") {
          stats = stats.call(this);
        }
        const ret = {
          total: Object.keys(stats).length,
          covered: Object.values(stats).filter((v) => !!v).length,
          skipped: 0
        };
        ret.pct = percent(ret.covered, ret.total);
        return ret;
      }
      computeBranchTotals(property) {
        const stats = this[property];
        const ret = { total: 0, covered: 0, skipped: 0 };
        Object.values(stats).forEach((branches) => {
          ret.covered += branches.filter((hits) => hits > 0).length;
          ret.total += branches.length;
        });
        ret.pct = percent(ret.covered, ret.total);
        return ret;
      }
      /**
       * resets hit counts for all statements, functions and branches
       * in this coverage object resulting in zero coverage.
       */
      resetHits() {
        const statements = this.s;
        const functions = this.f;
        const branches = this.b;
        const branchesTrue = this.bT;
        Object.keys(statements).forEach((s) => {
          statements[s] = 0;
        });
        Object.keys(functions).forEach((f) => {
          functions[f] = 0;
        });
        Object.keys(branches).forEach((b) => {
          branches[b].fill(0);
        });
        if (branchesTrue) {
          Object.keys(branchesTrue).forEach((bT) => {
            branchesTrue[bT].fill(0);
          });
        }
      }
      /**
       * returns a CoverageSummary for this file coverage object
       * @returns {CoverageSummary}
       */
      toSummary() {
        const ret = {};
        ret.lines = this.computeSimpleTotals("getLineCoverage");
        ret.functions = this.computeSimpleTotals("f", "fnMap");
        ret.statements = this.computeSimpleTotals("s", "statementMap");
        ret.branches = this.computeBranchTotals("b");
        if (this.bT) {
          ret.branchesTrue = this.computeBranchTotals("bT");
        }
        return new CoverageSummary(ret);
      }
    };
    dataProperties(FileCoverage, [
      "path",
      "statementMap",
      "fnMap",
      "branchMap",
      "s",
      "f",
      "b",
      "bT",
      "all"
    ]);
    module.exports = {
      FileCoverage,
      // exported for testing
      findNearestContainer,
      addHits,
      addNearestContainerHits
    };
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/coverage-map.js
var require_coverage_map = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/coverage-map.js"(exports, module) {
    "use strict";
    var { FileCoverage } = require_file_coverage();
    var { CoverageSummary } = require_coverage_summary();
    function maybeConstruct(obj, klass) {
      if (obj instanceof klass) {
        return obj;
      }
      return new klass(obj);
    }
    __name(maybeConstruct, "maybeConstruct");
    function loadMap(source) {
      const data = /* @__PURE__ */ Object.create(null);
      if (!source) {
        return data;
      }
      Object.entries(source).forEach(([k, cov]) => {
        data[k] = maybeConstruct(cov, FileCoverage);
      });
      return data;
    }
    __name(loadMap, "loadMap");
    var CoverageMap = class _CoverageMap {
      static {
        __name(this, "CoverageMap");
      }
      /**
       * @constructor
       * @param {Object} [obj=undefined] obj A coverage map from which to initialize this
       * map's contents. This can be the raw global coverage object.
       */
      constructor(obj) {
        if (obj instanceof _CoverageMap) {
          this.data = obj.data;
        } else {
          this.data = loadMap(obj);
        }
      }
      /**
       * merges a second coverage map into this one
       * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged
       *  correctly for the same files and additional file coverage keys are created
       *  as needed.
       */
      merge(obj) {
        const other = maybeConstruct(obj, _CoverageMap);
        Object.values(other.data).forEach((fc) => {
          this.addFileCoverage(fc);
        });
      }
      /**
       * filter the coveragemap based on the callback provided
       * @param {Function (filename)} callback - Returns true if the path
       *  should be included in the coveragemap. False if it should be
       *  removed.
       */
      filter(callback) {
        Object.keys(this.data).forEach((k) => {
          if (!callback(k)) {
            delete this.data[k];
          }
        });
      }
      /**
       * returns a JSON-serializable POJO for this coverage map
       * @returns {Object}
       */
      toJSON() {
        return this.data;
      }
      /**
       * returns an array for file paths for which this map has coverage
       * @returns {Array{string}} - array of files
       */
      files() {
        return Object.keys(this.data);
      }
      /**
       * returns the file coverage for the specified file.
       * @param {String} file
       * @returns {FileCoverage}
       */
      fileCoverageFor(file) {
        const fc = this.data[file];
        if (!fc) {
          throw new Error(`No file coverage available for: ${file}`);
        }
        return fc;
      }
      /**
       * adds a file coverage object to this map. If the path for the object,
       * already exists in the map, it is merged with the existing coverage
       * otherwise a new key is added to the map.
       * @param {FileCoverage} fc the file coverage to add
       */
      addFileCoverage(fc) {
        const cov = new FileCoverage(fc);
        const { path } = cov;
        if (this.data[path]) {
          this.data[path].merge(cov);
        } else {
          this.data[path] = cov;
        }
      }
      /**
       * returns the coverage summary for all the file coverage objects in this map.
       * @returns {CoverageSummary}
       */
      getCoverageSummary() {
        const ret = new CoverageSummary();
        Object.values(this.data).forEach((fc) => {
          ret.merge(fc.toSummary());
        });
        return ret;
      }
    };
    module.exports = {
      CoverageMap
    };
  }
});

// ../../node_modules/istanbul-lib-coverage/index.js
var require_istanbul_lib_coverage = __commonJS({
  "../../node_modules/istanbul-lib-coverage/index.js"(exports, module) {
    "use strict";
    var { FileCoverage } = require_file_coverage();
    var { CoverageMap } = require_coverage_map();
    var { CoverageSummary } = require_coverage_summary();
    module.exports = {
      /**
       * creates a coverage summary object
       * @param {Object} obj an argument with the same semantics
       *  as the one passed to the `CoverageSummary` constructor
       * @returns {CoverageSummary}
       */
      createCoverageSummary(obj) {
        if (obj && obj instanceof CoverageSummary) {
          return obj;
        }
        return new CoverageSummary(obj);
      },
      /**
       * creates a CoverageMap object
       * @param {Object} obj optional - an argument with the same semantics
       *  as the one passed to the CoverageMap constructor.
       * @returns {CoverageMap}
       */
      createCoverageMap(obj) {
        if (obj && obj instanceof CoverageMap) {
          return obj;
        }
        return new CoverageMap(obj);
      },
      /**
       * creates a FileCoverage object
       * @param {Object} obj optional - an argument with the same semantics
       *  as the one passed to the FileCoverage constructor.
       * @returns {FileCoverage}
       */
      createFileCoverage(obj) {
        if (obj && obj instanceof FileCoverage) {
          return obj;
        }
        return new FileCoverage(obj);
      }
    };
    module.exports.classes = {
      /**
       * the file coverage constructor
       */
      FileCoverage
    };
  }
});

// ../../node_modules/istanbul-lib-report/lib/path.js
var require_path = __commonJS({
  "../../node_modules/istanbul-lib-report/lib/path.js"(exports, module) {
    "use strict";
    var path = __require("path");
    var parsePath = path.parse;
    var SEP = path.sep;
    var origParser = parsePath;
    var origSep = SEP;
    function makeRelativeNormalizedPath(str, sep) {
      const parsed = parsePath(str);
      let root = parsed.root;
      let dir;
      let file = parsed.base;
      let quoted;
      let pos;
      if (sep === "\\") {
        pos = root.indexOf(":\\");
        if (pos >= 0) {
          root = root.substring(0, pos + 2);
        }
      }
      dir = parsed.dir.substring(root.length);
      if (str === "") {
        return [];
      }
      if (sep !== "/") {
        quoted = new RegExp(sep.replace(/\W/g, "\\$&"), "g");
        dir = dir.replace(quoted, "/");
        file = file.replace(quoted, "/");
      }
      if (dir !== "") {
        dir = `${dir}/${file}`;
      } else {
        dir = file;
      }
      if (dir.substring(0, 1) === "/") {
        dir = dir.substring(1);
      }
      dir = dir.split(/\/+/);
      return dir;
    }
    __name(makeRelativeNormalizedPath, "makeRelativeNormalizedPath");
    var Path = class _Path {
      static {
        __name(this, "Path");
      }
      constructor(strOrArray) {
        if (Array.isArray(strOrArray)) {
          this.v = strOrArray;
        } else if (typeof strOrArray === "string") {
          this.v = makeRelativeNormalizedPath(strOrArray, SEP);
        } else {
          throw new Error(
            `Invalid Path argument must be string or array:${strOrArray}`
          );
        }
      }
      toString() {
        return this.v.join("/");
      }
      hasParent() {
        return this.v.length > 0;
      }
      parent() {
        if (!this.hasParent()) {
          throw new Error("Unable to get parent for 0 elem path");
        }
        const p = this.v.slice();
        p.pop();
        return new _Path(p);
      }
      elements() {
        return this.v.slice();
      }
      name() {
        return this.v.slice(-1)[0];
      }
      contains(other) {
        let i;
        if (other.length > this.length) {
          return false;
        }
        for (i = 0; i < other.length; i += 1) {
          if (this.v[i] !== other.v[i]) {
            return false;
          }
        }
        return true;
      }
      ancestorOf(other) {
        return other.contains(this) && other.length !== this.length;
      }
      descendantOf(other) {
        return this.contains(other) && other.length !== this.length;
      }
      commonPrefixPath(other) {
        const len = this.length > other.length ? other.length : this.length;
        let i;
        const ret = [];
        for (i = 0; i < len; i += 1) {
          if (this.v[i] === other.v[i]) {
            ret.push(this.v[i]);
          } else {
            break;
          }
        }
        return new _Path(ret);
      }
      static compare(a, b) {
        const al = a.length;
        const bl = b.length;
        if (al < bl) {
          return -1;
        }
        if (al > bl) {
          return 1;
        }
        const astr = a.toString();
        const bstr = b.toString();
        return astr < bstr ? -1 : astr > bstr ? 1 : 0;
      }
    };
    ["push", "pop", "shift", "unshift", "splice"].forEach((fn) => {
      Object.defineProperty(Path.prototype, fn, {
        value(...args) {
          return this.v[fn](...args);
        }
      });
    });
    Object.defineProperty(Path.prototype, "length", {
      enumerable: true,
      get() {
        return this.v.length;
      }
    });
    module.exports = Path;
    Path.tester = {
      setParserAndSep(p, sep) {
        parsePath = p;
        SEP = sep;
      },
      reset() {
        parsePath = origParser;
        SEP = origSep;
      }
    };
  }
});

// ../../node_modules/istanbul-lib-report/lib/summarizer-factory.js
var require_summarizer_factory = __commonJS({
  "../../node_modules/istanbul-lib-report/lib/summarizer-factory.js"(exports, module) {
    "use strict";
    var coverage = require_istanbul_lib_coverage();
    var Path = require_path();
    var { BaseNode, BaseTree } = require_tree();
    var ReportNode = class _ReportNode extends BaseNode {
      static {
        __name(this, "ReportNode");
      }
      constructor(path, fileCoverage) {
        super();
        this.path = path;
        this.parent = null;
        this.fileCoverage = fileCoverage;
        this.children = [];
      }
      static createRoot(children) {
        const root = new _ReportNode(new Path([]));
        children.forEach((child) => {
          root.addChild(child);
        });
        return root;
      }
      addChild(child) {
        child.parent = this;
        this.children.push(child);
      }
      asRelative(p) {
        if (p.substring(0, 1) === "/") {
          return p.substring(1);
        }
        return p;
      }
      getQualifiedName() {
        return this.asRelative(this.path.toString());
      }
      getRelativeName() {
        const parent = this.getParent();
        const myPath = this.path;
        let relPath;
        let i;
        const parentPath = parent ? parent.path : new Path([]);
        if (parentPath.ancestorOf(myPath)) {
          relPath = new Path(myPath.elements());
          for (i = 0; i < parentPath.length; i += 1) {
            relPath.shift();
          }
          return this.asRelative(relPath.toString());
        }
        return this.asRelative(this.path.toString());
      }
      getParent() {
        return this.parent;
      }
      getChildren() {
        return this.children;
      }
      isSummary() {
        return !this.fileCoverage;
      }
      getFileCoverage() {
        return this.fileCoverage;
      }
      getCoverageSummary(filesOnly) {
        const cacheProp = `c_${filesOnly ? "files" : "full"}`;
        let summary;
        if (Object.prototype.hasOwnProperty.call(this, cacheProp)) {
          return this[cacheProp];
        }
        if (!this.isSummary()) {
          summary = this.getFileCoverage().toSummary();
        } else {
          let count = 0;
          summary = coverage.createCoverageSummary();
          this.getChildren().forEach((child) => {
            if (filesOnly && child.isSummary()) {
              return;
            }
            count += 1;
            summary.merge(child.getCoverageSummary(filesOnly));
          });
          if (count === 0 && filesOnly) {
            summary = null;
          }
        }
        this[cacheProp] = summary;
        return summary;
      }
    };
    var ReportTree = class extends BaseTree {
      static {
        __name(this, "ReportTree");
      }
      constructor(root, childPrefix) {
        super(root);
        const maybePrefix = /* @__PURE__ */ __name((node) => {
          if (childPrefix && !node.isRoot()) {
            node.path.unshift(childPrefix);
          }
        }, "maybePrefix");
        this.visit({
          onDetail: maybePrefix,
          onSummary(node) {
            maybePrefix(node);
            node.children.sort((a, b) => {
              const astr = a.path.toString();
              const bstr = b.path.toString();
              return astr < bstr ? -1 : astr > bstr ? 1 : (
                /* istanbul ignore next */
                0
              );
            });
          }
        });
      }
    };
    function findCommonParent(paths) {
      return paths.reduce(
        (common, path) => common.commonPrefixPath(path),
        paths[0] || new Path([])
      );
    }
    __name(findCommonParent, "findCommonParent");
    function findOrCreateParent(parentPath, nodeMap, created = () => {
    }) {
      let parent = nodeMap[parentPath.toString()];
      if (!parent) {
        parent = new ReportNode(parentPath);
        nodeMap[parentPath.toString()] = parent;
        created(parentPath, parent);
      }
      return parent;
    }
    __name(findOrCreateParent, "findOrCreateParent");
    function toDirParents(list) {
      const nodeMap = /* @__PURE__ */ Object.create(null);
      list.forEach((o) => {
        const parent = findOrCreateParent(o.path.parent(), nodeMap);
        parent.addChild(new ReportNode(o.path, o.fileCoverage));
      });
      return Object.values(nodeMap);
    }
    __name(toDirParents, "toDirParents");
    function addAllPaths(topPaths, nodeMap, path, node) {
      const parent = findOrCreateParent(
        path.parent(),
        nodeMap,
        (parentPath, parent2) => {
          if (parentPath.hasParent()) {
            addAllPaths(topPaths, nodeMap, parentPath, parent2);
          } else {
            topPaths.push(parent2);
          }
        }
      );
      parent.addChild(node);
    }
    __name(addAllPaths, "addAllPaths");
    function foldIntoOneDir(node, parent) {
      const { children } = node;
      if (children.length === 1 && !children[0].fileCoverage) {
        children[0].parent = parent;
        return foldIntoOneDir(children[0], parent);
      }
      node.children = children.map((child) => foldIntoOneDir(child, node));
      return node;
    }
    __name(foldIntoOneDir, "foldIntoOneDir");
    function pkgSummaryPrefix(dirParents, commonParent) {
      if (!dirParents.some((dp) => dp.path.length === 0)) {
        return;
      }
      if (commonParent.length === 0) {
        return "root";
      }
      return commonParent.name();
    }
    __name(pkgSummaryPrefix, "pkgSummaryPrefix");
    var SummarizerFactory = class {
      static {
        __name(this, "SummarizerFactory");
      }
      constructor(coverageMap, defaultSummarizer = "pkg") {
        this._coverageMap = coverageMap;
        this._defaultSummarizer = defaultSummarizer;
        this._initialList = coverageMap.files().map((filePath) => ({
          filePath,
          path: new Path(filePath),
          fileCoverage: coverageMap.fileCoverageFor(filePath)
        }));
        this._commonParent = findCommonParent(
          this._initialList.map((o) => o.path.parent())
        );
        if (this._commonParent.length > 0) {
          this._initialList.forEach((o) => {
            o.path.splice(0, this._commonParent.length);
          });
        }
      }
      get defaultSummarizer() {
        return this[this._defaultSummarizer];
      }
      get flat() {
        if (!this._flat) {
          this._flat = new ReportTree(
            ReportNode.createRoot(
              this._initialList.map(
                (node) => new ReportNode(node.path, node.fileCoverage)
              )
            )
          );
        }
        return this._flat;
      }
      _createPkg() {
        const dirParents = toDirParents(this._initialList);
        if (dirParents.length === 1) {
          return new ReportTree(dirParents[0]);
        }
        return new ReportTree(
          ReportNode.createRoot(dirParents),
          pkgSummaryPrefix(dirParents, this._commonParent)
        );
      }
      get pkg() {
        if (!this._pkg) {
          this._pkg = this._createPkg();
        }
        return this._pkg;
      }
      _createNested() {
        const nodeMap = /* @__PURE__ */ Object.create(null);
        const topPaths = [];
        this._initialList.forEach((o) => {
          const node = new ReportNode(o.path, o.fileCoverage);
          addAllPaths(topPaths, nodeMap, o.path, node);
        });
        const topNodes = topPaths.map((node) => foldIntoOneDir(node));
        if (topNodes.length === 1) {
          return new ReportTree(topNodes[0]);
        }
        return new ReportTree(ReportNode.createRoot(topNodes));
      }
      get nested() {
        if (!this._nested) {
          this._nested = this._createNested();
        }
        return this._nested;
      }
    };
    module.exports = SummarizerFactory;
  }
});

// ../../node_modules/istanbul-lib-report/lib/context.js
var require_context = __commonJS({
  "../../node_modules/istanbul-lib-report/lib/context.js"(exports, module) {
    "use strict";
    var fs = __require("fs");
    var FileWriter = require_file_writer();
    var XMLWriter = require_xml_writer();
    var tree = require_tree();
    var watermarks = require_watermarks();
    var SummarizerFactory = require_summarizer_factory();
    function defaultSourceLookup(path) {
      try {
        return fs.readFileSync(path, "utf8");
      } catch (ex) {
        throw new Error(`Unable to lookup source: ${path} (${ex.message})`);
      }
    }
    __name(defaultSourceLookup, "defaultSourceLookup");
    function normalizeWatermarks(specified = {}) {
      Object.entries(watermarks.getDefault()).forEach(([k, value]) => {
        const specValue = specified[k];
        if (!Array.isArray(specValue) || specValue.length !== 2) {
          specified[k] = value;
        }
      });
      return specified;
    }
    __name(normalizeWatermarks, "normalizeWatermarks");
    var Context = class {
      static {
        __name(this, "Context");
      }
      constructor(opts) {
        this.dir = opts.dir || "coverage";
        this.watermarks = normalizeWatermarks(opts.watermarks);
        this.sourceFinder = opts.sourceFinder || defaultSourceLookup;
        this._summarizerFactory = new SummarizerFactory(
          opts.coverageMap,
          opts.defaultSummarizer
        );
        this.data = {};
      }
      /**
       * returns a FileWriter implementation for reporting use. Also available
       * as the `writer` property on the context.
       * @returns {Writer}
       */
      getWriter() {
        return this.writer;
      }
      /**
       * returns the source code for the specified file path or throws if
       * the source could not be found.
       * @param {String} filePath the file path as found in a file coverage object
       * @returns {String} the source code
       */
      getSource(filePath) {
        return this.sourceFinder(filePath);
      }
      /**
       * returns the coverage class given a coverage
       * types and a percentage value.
       * @param {String} type - the coverage type, one of `statements`, `functions`,
       *  `branches`, or `lines`
       * @param {Number} value - the percentage value
       * @returns {String} one of `high`, `medium` or `low`
       */
      classForPercent(type, value) {
        const watermarks2 = this.watermarks[type];
        if (!watermarks2) {
          return "unknown";
        }
        if (value < watermarks2[0]) {
          return "low";
        }
        if (value >= watermarks2[1]) {
          return "high";
        }
        return "medium";
      }
      /**
       * returns an XML writer for the supplied content writer
       * @param {ContentWriter} contentWriter the content writer to which the returned XML writer
       *  writes data
       * @returns {XMLWriter}
       */
      getXMLWriter(contentWriter) {
        return new XMLWriter(contentWriter);
      }
      /**
       * returns a full visitor given a partial one.
       * @param {Object} partialVisitor a partial visitor only having the functions of
       *  interest to the caller. These functions are called with a scope that is the
       *  supplied object.
       * @returns {Visitor}
       */
      getVisitor(partialVisitor) {
        return new tree.Visitor(partialVisitor);
      }
      getTree(name = "defaultSummarizer") {
        return this._summarizerFactory[name];
      }
    };
    Object.defineProperty(Context.prototype, "writer", {
      enumerable: true,
      get() {
        if (!this.data.writer) {
          this.data.writer = new FileWriter(this.dir);
        }
        return this.data.writer;
      }
    });
    module.exports = Context;
  }
});

// ../../node_modules/istanbul-lib-report/lib/report-base.js
var require_report_base = __commonJS({
  "../../node_modules/istanbul-lib-report/lib/report-base.js"(exports, module) {
    "use strict";
    var _summarizer = Symbol("ReportBase.#summarizer");
    var ReportBase2 = class {
      static {
        __name(this, "ReportBase");
      }
      constructor(opts = {}) {
        this[_summarizer] = opts.summarizer;
      }
      execute(context) {
        context.getTree(this[_summarizer]).visit(this, context);
      }
    };
    module.exports = ReportBase2;
  }
});

// ../../node_modules/istanbul-lib-report/index.js
var require_istanbul_lib_report = __commonJS({
  "../../node_modules/istanbul-lib-report/index.js"(exports, module) {
    "use strict";
    var Context = require_context();
    var watermarks = require_watermarks();
    var ReportBase2 = require_report_base();
    module.exports = {
      /**
       * returns a reporting context for the supplied options
       * @param {Object} [opts=null] opts
       * @returns {Context}
       */
      createContext(opts) {
        return new Context(opts);
      },
      /**
       * returns the default watermarks that would be used when not
       * overridden
       * @returns {Object} an object with `statements`, `functions`, `branches`,
       *  and `line` keys. Each value is a 2 element array that has the low and
       *  high watermark as percentages.
       */
      getDefaultWatermarks() {
        return watermarks.getDefault();
      },
      /**
       * Base class for all reports
       */
      ReportBase: ReportBase2
    };
  }
});

// src/node/coverage-reporter.ts
var import_istanbul_lib_report = __toESM(require_istanbul_lib_report(), 1);
var StorybookCoverageReporter = class extends import_istanbul_lib_report.ReportBase {
  static {
    __name(this, "StorybookCoverageReporter");
  }
  #testManager;
  #coverageOptions;
  constructor(opts) {
    super();
    this.#testManager = opts.testManager;
    this.#coverageOptions = opts.coverageOptions;
  }
  onSummary(node) {
    if (!node.isRoot()) {
      return;
    }
    const rawCoverageSummary = node.getCoverageSummary(false);
    const percentage = Math.round(rawCoverageSummary.data.statements.pct);
    const [lowWatermark = 50, highWatermark = 80] = this.#coverageOptions?.watermarks?.statements ?? [];
    const coverageSummary = {
      percentage,
      status: percentage < lowWatermark ? "negative" : percentage < highWatermark ? "warning" : "positive"
    };
    this.#testManager.onCoverageCollected(coverageSummary);
  }
};
export {
  StorybookCoverageReporter as "module.exports"
};

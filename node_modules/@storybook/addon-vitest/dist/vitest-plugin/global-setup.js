import CJS_COMPAT_NODE_URL_vppyn5e0su from 'node:url';
import CJS_COMPAT_NODE_PATH_vppyn5e0su from 'node:path';
import CJS_COMPAT_NODE_MODULE_vppyn5e0su from "node:module";

var __filename = CJS_COMPAT_NODE_URL_vppyn5e0su.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_vppyn5e0su.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_vppyn5e0su.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  __commonJS,
  __name,
  __require,
  __toESM
} from "../_node-chunks/chunk-I3RGDGG2.js";

// ../../node_modules/tree-kill/index.js
var require_tree_kill = __commonJS({
  "../../node_modules/tree-kill/index.js"(exports, module) {
    "use strict";
    var childProcess = __require("child_process");
    var spawn2 = childProcess.spawn;
    var exec = childProcess.exec;
    module.exports = function(pid, signal, callback) {
      if (typeof signal === "function" && callback === void 0) {
        callback = signal;
        signal = void 0;
      }
      pid = parseInt(pid);
      if (Number.isNaN(pid)) {
        if (callback) {
          return callback(new Error("pid must be a number"));
        } else {
          throw new Error("pid must be a number");
        }
      }
      var tree = {};
      var pidsToProcess = {};
      tree[pid] = [];
      pidsToProcess[pid] = 1;
      switch (process.platform) {
        case "win32":
          exec("taskkill /pid " + pid + " /T /F", callback);
          break;
        case "darwin":
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn2("pgrep", ["-P", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
        // case 'sunos':
        //     buildProcessTreeSunOS(pid, tree, pidsToProcess, function () {
        //         killAll(tree, signal, callback);
        //     });
        //     break;
        default:
          buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
            return spawn2("ps", ["-o", "pid", "--no-headers", "--ppid", parentPid]);
          }, function() {
            killAll(tree, signal, callback);
          });
          break;
      }
    };
    function killAll(tree, signal, callback) {
      var killed = {};
      try {
        Object.keys(tree).forEach(function(pid) {
          tree[pid].forEach(function(pidpid) {
            if (!killed[pidpid]) {
              killPid(pidpid, signal);
              killed[pidpid] = 1;
            }
          });
          if (!killed[pid]) {
            killPid(pid, signal);
            killed[pid] = 1;
          }
        });
      } catch (err) {
        if (callback) {
          return callback(err);
        } else {
          throw err;
        }
      }
      if (callback) {
        return callback();
      }
    }
    __name(killAll, "killAll");
    function killPid(pid, signal) {
      try {
        process.kill(parseInt(pid, 10), signal);
      } catch (err) {
        if (err.code !== "ESRCH") throw err;
      }
    }
    __name(killPid, "killPid");
    function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
      var ps = spawnChildProcessesList(parentPid);
      var allData = "";
      ps.stdout.on("data", function(data) {
        var data = data.toString("ascii");
        allData += data;
      });
      var onClose = /* @__PURE__ */ __name(function(code) {
        delete pidsToProcess[parentPid];
        if (code != 0) {
          if (Object.keys(pidsToProcess).length == 0) {
            cb();
          }
          return;
        }
        allData.match(/\d+/g).forEach(function(pid) {
          pid = parseInt(pid, 10);
          tree[parentPid].push(pid);
          tree[pid] = [];
          pidsToProcess[pid] = 1;
          buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
        });
      }, "onClose");
      ps.on("close", onClose);
    }
    __name(buildProcessTree, "buildProcessTree");
  }
});

// src/vitest-plugin/global-setup.ts
var import_tree_kill = __toESM(require_tree_kill(), 1);
import { spawn } from "node:child_process";
import { logger } from "storybook/internal/node-logger";
var storybookProcess = null;
var getIsVitestStandaloneRun = /* @__PURE__ */ __name(() => {
  try {
    return (import.meta.env || process?.env).STORYBOOK !== "true";
  } catch (e) {
    return false;
  }
}, "getIsVitestStandaloneRun");
var isVitestStandaloneRun = getIsVitestStandaloneRun();
var checkStorybookRunning = /* @__PURE__ */ __name(async (storybookUrl) => {
  try {
    const response = await fetch(`${storybookUrl}/iframe.html`, { method: "HEAD" });
    return response.ok;
  } catch {
    return false;
  }
}, "checkStorybookRunning");
var startStorybookIfNotRunning = /* @__PURE__ */ __name(async () => {
  const storybookScript = process.env.__STORYBOOK_SCRIPT__;
  const storybookUrl = process.env.__STORYBOOK_URL__;
  const isRunning = await checkStorybookRunning(storybookUrl);
  if (isRunning) {
    logger.verbose("Storybook is already running");
    return;
  }
  logger.verbose(`Starting Storybook with command: ${storybookScript}`);
  try {
    storybookProcess = spawn(storybookScript, [], {
      stdio: process.env.DEBUG === "storybook" ? "pipe" : "ignore",
      cwd: process.cwd(),
      shell: true
    });
    storybookProcess.on("error", (error) => {
      logger.verbose("Failed to start Storybook:" + error.message);
      throw error;
    });
  } catch (error) {
    logger.verbose("Failed to start Storybook:" + error.message);
    throw error;
  }
}, "startStorybookIfNotRunning");
var setup = /* @__PURE__ */ __name(async ({ config }) => {
  if (config.watch && isVitestStandaloneRun) {
    await startStorybookIfNotRunning();
  }
}, "setup");
var teardown = /* @__PURE__ */ __name(async () => {
  if (!storybookProcess) {
    return;
  }
  logger.verbose("Stopping Storybook process");
  await new Promise((resolve, reject) => {
    if (storybookProcess?.pid) {
      (0, import_tree_kill.default)(storybookProcess.pid, "SIGTERM", (error) => {
        if (error) {
          logger.error("Failed to stop Storybook process:");
          reject(error);
          return;
        }
        resolve();
      });
    }
  });
}, "teardown");
export {
  setup,
  teardown
};

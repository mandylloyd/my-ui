import CJS_COMPAT_NODE_URL_vppyn5e0su from 'node:url';
import CJS_COMPAT_NODE_PATH_vppyn5e0su from 'node:path';
import CJS_COMPAT_NODE_MODULE_vppyn5e0su from "node:module";

var __filename = CJS_COMPAT_NODE_URL_vppyn5e0su.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_vppyn5e0su.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_vppyn5e0su.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  log,
  noop
} from "./_node-chunks/chunk-2NOXRFBQ.js";
import {
  execaNode,
  importMetaResolve
} from "./_node-chunks/chunk-MU5R4QJA.js";
import {
  ADDON_ID,
  COVERAGE_DIRECTORY,
  STATUS_STORE_CHANNEL_EVENT_NAME,
  STORE_CHANNEL_EVENT_NAME,
  STORYBOOK_ADDON_TEST_CHANNEL,
  TEST_PROVIDER_STORE_CHANNEL_EVENT_NAME,
  storeOptions
} from "./_node-chunks/chunk-BM6TFQ6X.js";
import {
  require_picocolors
} from "./_node-chunks/chunk-MYTTGGG2.js";
import {
  normalize
} from "./_node-chunks/chunk-TBLBCKKK.js";
import {
  __name,
  __toESM
} from "./_node-chunks/chunk-I3RGDGG2.js";

// src/preset.ts
import { mkdir } from "node:fs/promises";
import {
  createFileSystemCache,
  getFrameworkName,
  loadPreviewOrConfigFile,
  resolvePathInStorybookCache
} from "storybook/internal/common";
import {
  experimental_UniversalStore,
  experimental_getTestProviderStore
} from "storybook/internal/core-server";
import { cleanPaths, oneWayHash, sanitizeError, telemetry } from "storybook/internal/telemetry";

// ../../node_modules/es-toolkit/dist/predicate/isPlainObject.mjs
function isPlainObject(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
  if (!hasObjectPrototype) {
    return false;
  }
  return Object.prototype.toString.call(value) === "[object Object]";
}
__name(isPlainObject, "isPlainObject");

// ../../node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
__name(getSymbols, "getSymbols");

// ../../node_modules/es-toolkit/dist/compat/_internal/getTag.mjs
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}
__name(getTag, "getTag");

// ../../node_modules/es-toolkit/dist/compat/_internal/tags.mjs
var regexpTag = "[object RegExp]";
var stringTag = "[object String]";
var numberTag = "[object Number]";
var booleanTag = "[object Boolean]";
var argumentsTag = "[object Arguments]";
var symbolTag = "[object Symbol]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var setTag = "[object Set]";
var arrayTag = "[object Array]";
var functionTag = "[object Function]";
var arrayBufferTag = "[object ArrayBuffer]";
var objectTag = "[object Object]";
var errorTag = "[object Error]";
var dataViewTag = "[object DataView]";
var uint8ArrayTag = "[object Uint8Array]";
var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
var uint16ArrayTag = "[object Uint16Array]";
var uint32ArrayTag = "[object Uint32Array]";
var bigUint64ArrayTag = "[object BigUint64Array]";
var int8ArrayTag = "[object Int8Array]";
var int16ArrayTag = "[object Int16Array]";
var int32ArrayTag = "[object Int32Array]";
var bigInt64ArrayTag = "[object BigInt64Array]";
var float32ArrayTag = "[object Float32Array]";
var float64ArrayTag = "[object Float64Array]";

// ../../node_modules/es-toolkit/dist/compat/util/eq.mjs
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
__name(eq, "eq");

// ../../node_modules/es-toolkit/dist/predicate/isEqualWith.mjs
function isEqualWith(a, b, areValuesEqual) {
  return isEqualWithImpl(a, b, void 0, void 0, void 0, void 0, areValuesEqual);
}
__name(isEqualWith, "isEqualWith");
function isEqualWithImpl(a, b, property, aParent, bParent, stack, areValuesEqual) {
  const result = areValuesEqual(a, b, property, aParent, bParent, stack);
  if (result !== void 0) {
    return result;
  }
  if (typeof a === typeof b) {
    switch (typeof a) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined": {
        return a === b;
      }
      case "number": {
        return a === b || Object.is(a, b);
      }
      case "function": {
        return a === b;
      }
      case "object": {
        return areObjectsEqual(a, b, stack, areValuesEqual);
      }
    }
  }
  return areObjectsEqual(a, b, stack, areValuesEqual);
}
__name(isEqualWithImpl, "isEqualWithImpl");
function areObjectsEqual(a, b, stack, areValuesEqual) {
  if (Object.is(a, b)) {
    return true;
  }
  let aTag = getTag(a);
  let bTag = getTag(b);
  if (aTag === argumentsTag) {
    aTag = objectTag;
  }
  if (bTag === argumentsTag) {
    bTag = objectTag;
  }
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case stringTag:
      return a.toString() === b.toString();
    case numberTag: {
      const x = a.valueOf();
      const y = b.valueOf();
      return eq(x, y);
    }
    case booleanTag:
    case dateTag:
    case symbolTag:
      return Object.is(a.valueOf(), b.valueOf());
    case regexpTag: {
      return a.source === b.source && a.flags === b.flags;
    }
    case functionTag: {
      return a === b;
    }
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  const aStack = stack.get(a);
  const bStack = stack.get(b);
  if (aStack != null && bStack != null) {
    return aStack === b;
  }
  stack.set(a, b);
  stack.set(b, a);
  try {
    switch (aTag) {
      case mapTag: {
        if (a.size !== b.size) {
          return false;
        }
        for (const [key, value] of a.entries()) {
          if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case setTag: {
        if (a.size !== b.size) {
          return false;
        }
        const aValues = Array.from(a.values());
        const bValues = Array.from(b.values());
        for (let i = 0; i < aValues.length; i++) {
          const aValue = aValues[i];
          const index = bValues.findIndex((bValue) => {
            return isEqualWithImpl(aValue, bValue, void 0, a, b, stack, areValuesEqual);
          });
          if (index === -1) {
            return false;
          }
          bValues.splice(index, 1);
        }
        return true;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(a) !== Buffer.isBuffer(b)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (!isEqualWithImpl(a[i], b[i], i, a, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case arrayBufferTag: {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);
      }
      case dataViewTag: {
        if (a.byteLength !== b.byteLength || a.byteOffset !== b.byteOffset) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a), new Uint8Array(b), stack, areValuesEqual);
      }
      case errorTag: {
        return a.name === b.name && a.message === b.message;
      }
      case objectTag: {
        const areEqualInstances = areObjectsEqual(a.constructor, b.constructor, stack, areValuesEqual) || isPlainObject(a) && isPlainObject(b);
        if (!areEqualInstances) {
          return false;
        }
        const aKeys = [...Object.keys(a), ...getSymbols(a)];
        const bKeys = [...Object.keys(b), ...getSymbols(b)];
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        for (let i = 0; i < aKeys.length; i++) {
          const propKey = aKeys[i];
          const aProp = a[propKey];
          if (!Object.hasOwn(b, propKey)) {
            return false;
          }
          const bProp = b[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      default: {
        return false;
      }
    }
  } finally {
    stack.delete(a);
    stack.delete(b);
  }
}
__name(areObjectsEqual, "areObjectsEqual");

// ../../node_modules/es-toolkit/dist/predicate/isEqual.mjs
function isEqual(a, b) {
  return isEqualWith(a, b, noop);
}
__name(isEqual, "isEqual");

// src/preset.ts
var import_picocolors = __toESM(require_picocolors(), 1);
import { dedent } from "ts-dedent";

// src/node/boot-test-runner.ts
import { fileURLToPath } from "node:url";
import {
  internal_universalStatusStore,
  internal_universalTestProviderStore
} from "storybook/internal/core-server";
var MAX_START_TIME = 3e4;
var vitestModulePath = fileURLToPath(importMetaResolve("@storybook/addon-vitest/vitest"));
var eventQueue = [];
var child;
var ready = false;
var unsubscribeStore;
var unsubscribeStatusStore;
var unsubscribeTestProviderStore;
var forwardUniversalStoreEvent = /* @__PURE__ */ __name((storeEventName) => (event, eventInfo) => {
  child?.send({
    type: storeEventName,
    args: [{ event, eventInfo }],
    from: "server"
  });
}, "forwardUniversalStoreEvent");
var bootTestRunner = /* @__PURE__ */ __name(async ({
  channel,
  store,
  options
}) => {
  let stderr = [];
  const killChild = /* @__PURE__ */ __name(() => {
    unsubscribeStore?.();
    unsubscribeStatusStore?.();
    unsubscribeTestProviderStore?.();
    child?.kill();
    child = null;
  }, "killChild");
  store.subscribe("FATAL_ERROR", killChild);
  const exit = /* @__PURE__ */ __name((code = 0) => {
    killChild();
    eventQueue.length = 0;
    process.exit(code);
  }, "exit");
  process.on("exit", exit);
  process.on("SIGINT", () => exit(0));
  process.on("SIGTERM", () => exit(0));
  const startChildProcess = /* @__PURE__ */ __name(() => new Promise((resolve, reject) => {
    child = execaNode(vitestModulePath, {
      env: {
        VITEST: "true",
        TEST: "true",
        VITEST_CHILD_PROCESS: "true",
        NODE_ENV: process.env.NODE_ENV ?? "test",
        STORYBOOK_CONFIG_DIR: normalize(options.configDir)
      },
      extendEnv: true
    });
    stderr = [];
    child.stdout?.on("data", log);
    child.stderr?.on("data", (data) => {
      if (!data.toString().match(/^\u001B\[33m/)) {
        log(data);
        stderr.push(data.toString());
      }
    });
    unsubscribeStore = store.subscribe(forwardUniversalStoreEvent(STORE_CHANNEL_EVENT_NAME));
    unsubscribeStatusStore = internal_universalStatusStore.subscribe(
      forwardUniversalStoreEvent(STATUS_STORE_CHANNEL_EVENT_NAME)
    );
    unsubscribeTestProviderStore = internal_universalTestProviderStore.subscribe(
      forwardUniversalStoreEvent(TEST_PROVIDER_STORE_CHANNEL_EVENT_NAME)
    );
    child.on("message", (event) => {
      if (event.type === "ready") {
        while (eventQueue.length) {
          const { type, args } = eventQueue.shift();
          child?.send({ type, args, from: "server" });
        }
        resolve();
      } else if (event.type === "uncaught-error") {
        store.send({
          type: "FATAL_ERROR",
          payload: event.payload
        });
        reject();
      } else {
        channel.emit(event.type, ...event.args);
      }
    });
  }), "startChildProcess");
  const timeout = new Promise(
    (_, reject) => setTimeout(
      reject,
      MAX_START_TIME,
      // eslint-disable-next-line local-rules/no-uncategorized-errors
      new Error(
        `Aborting test runner process because it took longer than ${MAX_START_TIME / 1e3} seconds to start.`
      )
    )
  );
  await Promise.race([startChildProcess(), timeout]).catch((error) => {
    store.send({
      type: "FATAL_ERROR",
      payload: {
        message: "Failed to start test runner process",
        error: {
          message: error.message,
          name: error.name,
          stack: error.stack,
          cause: error.cause
        }
      }
    });
    eventQueue.length = 0;
    throw error;
  });
}, "bootTestRunner");
var runTestRunner = /* @__PURE__ */ __name(async ({
  channel,
  store,
  initEvent,
  initArgs,
  options
}) => {
  if (!ready && initEvent) {
    eventQueue.push({ type: initEvent, args: initArgs });
  }
  if (!child) {
    ready = false;
    await bootTestRunner({ channel, store, options });
    ready = true;
  }
}, "runTestRunner");

// src/preset.ts
var experimental_serverChannel = /* @__PURE__ */ __name(async (channel, options) => {
  const core = await options.presets.apply("core");
  const previewPath = loadPreviewOrConfigFile({ configDir: options.configDir });
  const previewAnnotations = await options.presets.apply(
    "previewAnnotations",
    [],
    options
  );
  const resolvedPreviewBuilder = typeof core?.builder === "string" ? core.builder : core?.builder?.name;
  const framework = await getFrameworkName(options);
  if (!resolvedPreviewBuilder?.includes("vite")) {
    if (framework.includes("nextjs")) {
      log(dedent`
        You're using ${framework}, which is a Webpack-based builder. In order to use Storybook Test, with your project, you need to use '@storybook/nextjs-vite', a high performance Vite-based equivalent.

        Information on how to upgrade here: ${import_picocolors.default.yellow("https://storybook.js.org/docs/get-started/frameworks/nextjs?ref=upgrade#with-vite")}\n
      `);
    }
    return channel;
  }
  const fsCache = createFileSystemCache({
    basePath: resolvePathInStorybookCache(ADDON_ID.replace("/", "-")),
    ns: "storybook",
    ttl: 14 * 24 * 60 * 60 * 1e3
    // 14 days
  });
  const cachedState = await fsCache.get("state", {
    config: storeOptions.initialState.config
  });
  const selectCachedState = /* @__PURE__ */ __name((s) => ({
    config: s.config
  }), "selectCachedState");
  const store = experimental_UniversalStore.create({
    ...storeOptions,
    initialState: {
      ...storeOptions.initialState,
      previewAnnotations: (previewAnnotations ?? []).concat(previewPath ?? []),
      ...selectCachedState(cachedState)
    },
    leader: true
  });
  store.onStateChange((state, previousState) => {
    if (!isEqual(selectCachedState(state), selectCachedState(previousState))) {
      fsCache.set("state", selectCachedState(state));
    }
  });
  const testProviderStore = experimental_getTestProviderStore(ADDON_ID);
  store.subscribe("TRIGGER_RUN", (event, eventInfo) => {
    testProviderStore.setState("test-provider-state:running");
    store.setState((s) => ({
      ...s,
      fatalError: void 0
    }));
    runTestRunner({
      channel,
      store,
      initEvent: STORE_CHANNEL_EVENT_NAME,
      initArgs: [{ event, eventInfo }],
      options
    });
  });
  store.subscribe("TOGGLE_WATCHING", (event, eventInfo) => {
    store.setState((s) => ({
      ...s,
      watching: event.payload.to,
      currentRun: {
        ...s.currentRun,
        // when enabling watch mode, clear the coverage summary too
        ...event.payload.to && {
          coverageSummary: void 0
        }
      }
    }));
    if (event.payload.to) {
      runTestRunner({
        channel,
        store,
        initEvent: STORE_CHANNEL_EVENT_NAME,
        initArgs: [{ event, eventInfo }],
        options
      });
    }
  });
  store.subscribe("FATAL_ERROR", (event) => {
    const { message, error } = event.payload;
    const name = error.name || "Error";
    log(`${name}: ${message}`);
    if (error.stack) {
      log(error.stack);
    }
    function logErrorWithCauses(err) {
      if (!err) {
        return;
      }
      log(`Caused by: ${err.name ?? "Error"}: ${err.message}`);
      if (err.stack) {
        log(err.stack);
      }
      if (err.cause) {
        logErrorWithCauses(err.cause);
      }
    }
    __name(logErrorWithCauses, "logErrorWithCauses");
    if (error.cause) {
      logErrorWithCauses(error.cause);
    }
    store.setState((s) => ({
      ...s,
      fatalError: {
        message,
        error
      }
    }));
    testProviderStore.setState("test-provider-state:crashed");
  });
  testProviderStore.onClearAll(() => {
    store.setState((s) => ({
      ...s,
      currentRun: { ...s.currentRun, coverageSummary: void 0, unhandledErrors: [] }
    }));
  });
  if (!core.disableTelemetry) {
    const enableCrashReports = core.enableCrashReports || options.enableCrashReports;
    channel.on(STORYBOOK_ADDON_TEST_CHANNEL, (event) => {
      telemetry("addon-test", {
        ...event,
        payload: {
          ...event.payload,
          storyId: oneWayHash(event.payload.storyId)
        }
      });
    });
    store.subscribe("TOGGLE_WATCHING", async (event) => {
      await telemetry("addon-test", {
        watchMode: event.payload.to
      });
    });
    store.subscribe("TEST_RUN_COMPLETED", async (event) => {
      const { unhandledErrors, startedAt, finishedAt, ...currentRun } = event.payload;
      await telemetry("addon-test", {
        ...currentRun,
        duration: (finishedAt ?? 0) - (startedAt ?? 0),
        unhandledErrorCount: unhandledErrors.length,
        ...enableCrashReports && unhandledErrors.length > 0 && {
          unhandledErrors: unhandledErrors.map((error) => {
            const { stacks, ...errorWithoutStacks } = error;
            return sanitizeError(errorWithoutStacks);
          })
        }
      });
    });
    if (enableCrashReports) {
      store.subscribe("FATAL_ERROR", async (event) => {
        await telemetry("addon-test", {
          fatalError: cleanPaths(event.payload.error.message)
        });
      });
    }
  }
  return channel;
}, "experimental_serverChannel");
var staticDirs = /* @__PURE__ */ __name(async (values = [], options) => {
  if (options.configType === "PRODUCTION") {
    return values;
  }
  const coverageDirectory = resolvePathInStorybookCache(COVERAGE_DIRECTORY);
  await mkdir(coverageDirectory, { recursive: true });
  return [
    {
      from: coverageDirectory,
      to: "/coverage"
    },
    ...values
  ];
}, "staticDirs");
export {
  experimental_serverChannel,
  staticDirs
};
